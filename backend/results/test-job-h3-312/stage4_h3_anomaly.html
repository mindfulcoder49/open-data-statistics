<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>H3-Based Spatial Time Series Analysis Report</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/h3-js@4.1.0/dist/h3-js.umd.js"></script>
    <style>
        body { font-family: sans-serif; line-height: 1.6; color: #333; max-width: 1200px; margin: 0 auto; padding: 20px; }
        h1, h2, h3, h4, h5 { color: #2c3e50; }
        h2 { border-bottom: 2px solid #ecf0f1; padding-bottom: 10px; }
        h3 { border-bottom: 1px solid #ecf0f1; padding-bottom: 8px; }
        code { background-color: #ecf0f1; padding: 2px 5px; border-radius: 4px; }
        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .finding-group { border: 1px solid #ccc; border-radius: 5px; padding: 15px; margin-bottom: 20px; background-color: #fafafa; }
        .finding-card { border: 1px solid #e0e0e0; border-radius: 5px; padding: 15px; margin-bottom: 15px; background-color: #fff; }
        img { margin-top: 10px; max-width: 100%; }
        #map { height: 500px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 20px; }
        .loader { text-align: center; padding: 40px; font-size: 1.2em; }
    </style>
</head>
<body>
    <h1>Scholarly Report on H3-Based Spatial Time Series Analysis</h1>
    <div id="methodology-container">
        <!-- Methodology will be injected here by the reporter -->
        <h2>1. Methodology</h2>
The analytical approach comprises several sequential steps: spatial aggregation, data preparation, model selection, and independent significance testing.
<h3>1.1. Spatial Aggregation and Data Preparation</h3>
<p>Raw incident data points were assigned to a hexagonal H3 cell based on their latitude and longitude coordinates, using H3 resolution <code>9</code>. The data was then further partitioned into subgroups based on unique combinations of the H3 cell and the <code>type</code> field. For each subgroup, a time series was constructed by resampling the data into weekly incident counts. A minimum of eight weeks of data was required for a subgroup to be included in the analysis.</p>
<h3>1.2. Probabilistic Model Selection and Anomaly/Trend Detection</h3>
<p>The methodology for model selection (Poisson vs. Negative Binomial), anomaly detection (p-value and z-score for the last four weeks), and trend detection (linear regression on the last four weeks) is identical to that used in the standard univariate analysis. Please refer to that report for detailed descriptions.</p>
<h3>1.3. Significance Testing and Noise Reduction</h3>
<p>Each time series is treated as an independent hypothesis test. A conventional significance level (alpha) of <strong>0.05</strong> is used. A finding is reported as statistically significant if its p-value is less than this threshold. To reduce noise, anomalies are only reported for low-frequency series if the observed count is greater than 1.</p>
    </div>

    <h2>2. Spatial Overview of Findings</h2>
    <p>The following interactive map displays all H3 hexagonal cells that contained at least one significant finding (anomaly or trend). Click on a hexagon for a summary of its findings.</p>
    <div id="map"></div>

    <h2>3. Summary of All Significant Findings</h2>
    <div id="summary-table-container">
        <div class="loader">Loading findings...</div>
    </div>

    <h2>4. Detailed Analysis by H3 Cell</h2>
    <div id="detailed-findings-container">
        <div class="loader">Loading details...</div>
    </div>

    <div id="appendix-container">
        <!-- Appendix will be injected here by the reporter -->
        <hr><h2>Appendix: Definition of Terms</h2>
<ul>
<li><strong>H3</strong>: A geospatial indexing system that partitions the world into hexagonal cells. It allows for efficient spatial analysis at various resolutions.</li>
<li><strong>Leaflet.js</strong>: An open-source JavaScript library for mobile-friendly interactive maps.</li>
<li><strong>Poisson Distribution</strong>: A discrete probability distribution for the counts of events that occur randomly in a given interval of time or space.</li>
<li><strong>Negative Binomial Distribution</strong>: A generalization of the Poisson distribution that allows for overdispersion, where the variance is greater than the mean.</li>
<li><strong>P-value</strong>: The probability of obtaining test results at least as extreme as the results actually observed, under the assumption that the null hypothesis is correct.</li>
<li><strong>Z-score</strong>: A measure of how many standard deviations an observation or data point is from the mean of a distribution. It provides a standardized measure of an anomaly's magnitude.</li>
</ul>
    </div>

<script>
document.addEventListener('DOMContentLoaded', function () {
    const P_VALUE_THRESHOLD = 0.05;
    // The JSON data will be embedded here by the reporter
    const analysisData = '{{JSON_DATA}}';

    const map = L.map('map').setView([42.3601, -71.0589], 12); // Default center
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
    }).addTo(map);

    try {
        const data = analysisData;
        const params = data.parameters;
        const h3Col = `h3_index_${params.h3_resolution}`;
        const secondaryCol = params.secondary_group_col;

        // --- Identify all significant findings ---
        const allFindings = [];
        data.results.forEach(row => {
            const trendP = row.trend_analysis.p_value;
            if (trendP !== null && trendP < P_VALUE_THRESHOLD) {
                    allFindings.push({ type: 'Trend', details: row });
                }
                row.last_4_weeks_analysis.forEach(week => {
                    const anomalyP = week.anomaly_p_value;
                    if (anomalyP !== null && anomalyP < P_VALUE_THRESHOLD) {
                        if (row.historical_weekly_avg < 1 && week.count === 1) return;
                        allFindings.push({ type: 'Anomaly', details: row, week_details: week });
                    }
                });
            });

            if (allFindings.length === 0) {
                document.getElementById('summary-table-container').innerHTML = "<p>No statistically significant trends or anomalies were detected.</p>";
                document.getElementById('detailed-findings-container').innerHTML = "";
                return;
            }
            
            // --- Update Map ---
            updateMap(allFindings, h3Col, secondaryCol);
            
            // --- Update Summary Table ---
            populateSummaryTable(allFindings, h3Col, secondaryCol);

            // --- Update Detailed Findings ---
            populateDetailedFindings(allFindings, data.city_wide_results, h3Col, secondaryCol);
        })
        .catch(error => {
            console.error('Error loading or processing analysis data:', error);
            document.getElementById('summary-table-container').innerHTML = `<p style="color:red;">Error loading report data: ${error.message}</p>`;
            document.getElementById('detailed-findings-container').innerHTML = "";
        });

    function updateMap(findings, h3Col, secondaryCol) {
        const h3Summary = {};
        findings.forEach(finding => {
            const details = finding.details;
            const h3Index = details[h3Col];
            if (!h3Summary[h3Index]) {
                h3Summary[h3Index] = { trends: [], anomalies: [], lat: details.lat, lon: details.lon };
            }
            if (finding.type === 'Trend') h3Summary[h3Index].trends.push(details);
            else h3Summary[h3Index].anomalies.push(finding);
        });

        const allLats = findings.map(f => f.details.lat);
        const allLons = findings.map(f => f.details.lon);
        if (allLats.length > 0) {
            const avgLat = allLats.reduce((a, b) => a + b, 0) / allLats.length;
            const avgLon = allLons.reduce((a, b) => a + b, 0) / allLons.length;
            map.setView([avgLat, avgLon], 12);
        }

        Object.keys(h3Summary).forEach(h3Index => {
            const summary = h3Summary[h3Index];
            const boundary = h3.cellToBoundary(h3Index, true); // Get [lon, lat] pairs
            const leafletBoundary = boundary.map(p => [p[1], p[0]]); // Convert to [lat, lon] for Leaflet

            const numTrends = summary.trends.length;
            const numAnomalies = summary.anomalies.length;

            let popupHtml = `<b>Hexagon:</b> ${h3Index}<br><b>Trends:</b> ${numTrends}<br><b>Anomalies:</b> ${numAnomalies}<hr>`;
            if (numTrends > 0) {
                popupHtml += "<b>Trends:</b><ul>";
                summary.trends.forEach(t => popupHtml += `<li>${t[secondaryCol]}: ${t.trend_analysis.description} (p=${t.trend_analysis.p_value.toPrecision(2)})</li>`);
                popupHtml += "</ul>";
            }
            if (numAnomalies > 0) {
                popupHtml += "<b>Anomalies:</b><ul>";
                summary.anomalies.forEach(a => popupHtml += `<li>${a.details[secondaryCol]} on ${a.week_details.week}: Count ${a.week_details.count} (p=${a.week_details.anomaly_p_value.toPrecision(2)})</li>`);
                popupHtml += "</ul>";
            }

            const fillColor = numAnomalies > 0 ? 'red' : 'blue';
            const fillOpacity = (numAnomalies + numTrends) > 0 ? 0.6 : 0.2;

            L.polygon(leafletBoundary, { color: 'black', weight: 1, fillColor, fillOpacity })
                .addTo(map)
                .bindPopup(popupHtml)
                .bindTooltip(`${h3Index}: ${numTrends} trend(s), ${numAnomalies} anomaly(s)`);
        });
    }

    function populateSummaryTable(findings, h3Col, secondaryCol) {
        findings.sort((a, b) => {
            const pValA = a.type === 'Trend' ? a.details.trend_analysis.p_value : a.week_details.anomaly_p_value;
            const pValB = b.type === 'Trend' ? b.details.trend_analysis.p_value : b.week_details.anomaly_p_value;
            return a.details[h3Col].localeCompare(b.details[h3Col]) || pValA - pValB;
        });

        let tableHtml = `<table><thead><tr><th>H3 Cell</th><th>${secondaryCol}</th><th>Finding Type</th><th>Date/Period</th><th>Details</th><th>P-Value</th><th>Z-Score / Slope</th></tr></thead><tbody>`;
        findings.forEach(finding => {
            const details = finding.details;
            tableHtml += `<tr><td><a href='#${details[h3Col]}'>${details[h3Col]}</a></td><td>${details[secondaryCol]}</td>`;
            if (finding.type === 'Trend') {
                const trend = details.trend_analysis;
                tableHtml += `<td>Trend</td><td>Last 4 Weeks</td><td>${trend.description}</td><td>${trend.p_value.toPrecision(4)}</td><td>${trend.slope.toFixed(2)}</td>`;
            } else {
                const week = finding.week_details;
                tableHtml += `<td>Anomaly</td><td>${week.week}</td><td>Count: ${week.count} (vs avg ${details.historical_weekly_avg.toFixed(2)})</td><td>${week.anomaly_p_value.toPrecision(4)}</td><td>${week.z_score.toFixed(2)}</td>`;
            }
            tableHtml += "</tr>";
        });
        tableHtml += '</tbody></table>';
        document.getElementById('summary-table-container').innerHTML = tableHtml;
    }

    function populateDetailedFindings(findings, cityWideResults, h3Col, secondaryCol) {
        const findingsByH3 = {};
        findings.forEach(f => {
            const h3Index = f.details[h3Col];
            if (!findingsByH3[h3Index]) findingsByH3[h3Index] = [];
            findingsByH3[h3Index].push(f);
        });

        const cityWideMap = {};
        cityWideResults.forEach(item => cityWideMap[item[secondaryCol]] = item);

        let detailedHtml = '';
        Object.keys(findingsByH3).sort().forEach(h3Index => {
            detailedHtml += `<div class="finding-group" id="${h3Index}"><h4>Hexagon: ${h3Index}</h4>`;
            findingsByH3[h3Index].forEach(finding => {
                const details = finding.details;
                const secGroup = details[secondaryCol];
                
                detailedHtml += `<div class="finding-card">`;
                if (finding.type === 'Trend') {
                    const trend = details.trend_analysis;
                    detailedHtml += `<h5>Finding: Trend in '${secGroup}'</h5><ul>
                        <li><strong>Description</strong>: ${trend.description}</li>
                        <li><strong>Weekly Change (Slope)</strong>: ${trend.slope.toFixed(2)}</li>
                        <li><strong>Significance (p-value)</strong>: ${trend.p_value.toPrecision(4)}</li></ul>`;
                } else {
                    const week = finding.week_details;
                    detailedHtml += `<h5>Finding: Anomaly in '${secGroup}'</h5><ul>
                        <li><strong>Date</strong>: ${week.week}</li>
                        <li><strong>Observed Count</strong>: ${week.count} (Historical Avg: ${details.historical_weekly_avg.toFixed(2)})</li>
                        <li><strong>Magnitude (Z-Score)</strong>: ${week.z_score.toFixed(2)}</li>
                        <li><strong>Significance (p-value)</strong>: ${week.anomaly_p_value.toPrecision(4)}</li></ul>`;
                }
                // Note: Plot generation is not included in this client-side version for simplicity.
                // To include plots, they would need to be generated and saved by the Python process,
                // and this script would reference them by a predictable filename.
                detailedHtml += '</div>';
            });
            detailedHtml += '</div>';
        });
        document.getElementById('detailed-findings-container').innerHTML = detailedHtml;
    }
});
</script>
</body>
</html>
