<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>H3-Based Spatial Time Series Analysis Report</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/h3-js@4.1.0/dist/h3-js.umd.js"></script>
    <style>
        body { font-family: sans-serif; line-height: 1.6; color: #333; max-width: 1200px; margin: 0 auto; padding: 20px; }
        h1, h2, h3, h4, h5 { color: #2c3e50; }
        h2 { border-bottom: 2px solid #ecf0f1; padding-bottom: 10px; }
        h3 { border-bottom: 1px solid #ecf0f1; padding-bottom: 8px; }
        code { background-color: #ecf0f1; padding: 2px 5px; border-radius: 4px; }
        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .finding-group { border: 1px solid #ccc; border-radius: 5px; padding: 15px; margin-bottom: 20px; background-color: #fafafa; }
        .finding-card { border: 1px solid #e0e0e0; border-radius: 5px; padding: 15px; margin-bottom: 15px; background-color: #fff; }
        img { margin-top: 10px; max-width: 100%; }
        .map-container { height: 500px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 20px; }
        .loader { text-align: center; padding: 40px; font-size: 1.2em; }
        #job-id-header { font-size: 1.2em; color: #7f8c8d; }
        .filter-notice { background-color: #eaf2f8; border-left: 5px solid #3498db; padding: 10px 20px; margin-bottom: 20px; }
        .legend { padding: 6px 8px; font: 14px/16px Arial, Helvetica, sans-serif; background: white; background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px; }
        .legend i { width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.7; }
    </style>
</head>
<body>
    <h1>Scholarly Report on H3-Based Spatial Time Series Analysis</h1>
    <h2 id="job-id-header">Job ID: <span id="job-id-placeholder"></span></h2>

    <div id="filter-notice-container"></div>
    <div id="methodology-container"></div>

    <h2>2. Spatial Overview of Anomalies</h2>
    <p>The following interactive map displays H3 hexagonal cells containing statistically significant anomalies. The color of each hexagon corresponds to the number of distinct anomaly types found within it.</p>
    <div id="map-anomalies" class="map-container"></div>

    <h2 id="trends-header">3. Spatial Overview of Trends</h2>
    <p id="trends-description">The following interactive map displays H3 hexagonal cells containing statistically significant trends. Red indicates an upward trend in incident counts, while blue indicates a downward trend.</p>
    <div id="map-trends" class="map-container"></div>

    <h2>4. Summary of All Significant Findings</h2>
    <div id="summary-table-container">
        <div class="loader">Loading findings...</div>
    </div>

    <h2>5. Detailed Analysis by H3 Cell</h2>
    <div id="detailed-findings-container">
        <div class="loader">Loading details...</div>
    </div>

    <div id="appendix-container"></div>

<script>
document.addEventListener('DOMContentLoaded', function () {
    // Default values
    let P_VALUE_ANOMALY = 0.05;
    let P_VALUE_TREND = 0.05;
    let ANALYSIS_WEEKS_TREND = [4];
    let ANALYSIS_WEEKS_ANOMALY = 4;

    const params = new URLSearchParams(window.location.search);
    const jobId = params.get('job_id');

    if (!jobId) {
        document.body.innerHTML = '<h1>Error: No Job ID provided. Please add ?job_id=YOUR_JOB_ID to the URL.</h1>';
        return;
    }

    document.getElementById('job-id-placeholder').textContent = jobId;
    const JSON_PATH = `/api/v1/jobs/${jobId}/results/stage4_h3_anomaly.json`;

    const mapAnomalies = L.map('map-anomalies').setView([42.3601, -71.0589], 12);
    const mapTrends = L.map('map-trends').setView([42.3601, -71.0589], 12);

    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
    }).addTo(mapAnomalies);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
    }).addTo(mapTrends);

    fetch(JSON_PATH)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            const params = data.parameters;
            const h3Col = `h3_index_${params.h3_resolution}`;
            const secondaryCol = params.secondary_group_col;

            // --- Set configurable parameters ---
            P_VALUE_ANOMALY = params.p_value_anomaly || 0.05;
            P_VALUE_TREND = params.p_value_trend || 0.05;
            ANALYSIS_WEEKS_TREND = params.analysis_weeks_trend || [4];
            ANALYSIS_WEEKS_ANOMALY = params.analysis_weeks_anomaly || 4;

            // --- Update dynamic text ---
            document.getElementById('trends-header').textContent = `3. Spatial Overview of Trends`;
            document.getElementById('trends-description').textContent = `The following interactive map displays H3 hexagonal cells containing statistically significant trends over the specified analysis windows (${ANALYSIS_WEEKS_TREND.join(', ')} weeks). Red indicates an upward trend in incident counts, while blue indicates a downward trend. A trend is considered significant if its p-value is less than ${P_VALUE_TREND}.`;
            
            // --- Populate Methodology & Appendix ---
            document.getElementById('methodology-container').innerHTML = generateMethodology(secondaryCol, params.h3_resolution, P_VALUE_ANOMALY, P_VALUE_TREND, ANALYSIS_WEEKS_TREND, ANALYSIS_WEEKS_ANOMALY);
            document.getElementById('appendix-container').innerHTML = generateAppendix();

            // --- Display filter notice if applicable ---
            if (params.filter_col && params.filter_values && params.filter_values.length > 0) {
                const noticeHtml = `<div class="filter-notice">
                    <p><strong>Filter Applied:</strong> This report was generated on a subset of the data where the column <code>${params.filter_col}</code> has one of the following values: <code>${params.filter_values.join(', ')}</code>.</p>
                </div>`;
                document.getElementById('filter-notice-container').innerHTML = noticeHtml;
            }

            // --- Identify all significant findings ---
            const allFindings = [];
            const anomalyFindings = [];
            const trendFindings = [];

            data.results.forEach(row => {
                const trendAnalyses = row.trend_analysis;
                if (trendAnalyses) {
                    for (const [period, trend] of Object.entries(trendAnalyses)) {
                        if (trend.p_value !== null && trend.p_value < P_VALUE_TREND) {
                            const finding = { type: 'Trend', details: row, trend_details: trend, period: period };
                            allFindings.push(finding);
                            trendFindings.push(finding);
                        }
                    }
                }
                // FIX: Use the correct key 'anomaly_analysis' instead of 'last_4_weeks_analysis'
                if (row.anomaly_analysis) {
                    row.anomaly_analysis.forEach(week => {
                        const anomalyP = week.anomaly_p_value;
                        if (anomalyP !== null && anomalyP < P_VALUE_ANOMALY) {
                            if (row.historical_weekly_avg < 1 && week.count === 1) return;
                            const finding = { type: 'Anomaly', details: row, week_details: week };
                            allFindings.push(finding);
                            anomalyFindings.push(finding);
                        }
                    });
                }
            });

            if (allFindings.length === 0) {
                document.getElementById('summary-table-container').innerHTML = "<p>No statistically significant trends or anomalies were detected.</p>";
                document.getElementById('detailed-findings-container').innerHTML = "";
                document.getElementById('map-anomalies').innerHTML = "<p>No anomalies found.</p>";
                document.getElementById('map-trends').innerHTML = "<p>No trends found.</p>";
                return;
            }
            
            updateAnomaliesMap(anomalyFindings, h3Col, secondaryCol);
            updateTrendsMap(trendFindings, h3Col, secondaryCol);
            populateSummaryTable(allFindings, h3Col, secondaryCol);
            populateDetailedFindings(allFindings, data.city_wide_results, h3Col, secondaryCol);
        })
        .catch(error => {
            console.error('Error loading or processing analysis data:', error);
            document.getElementById('summary-table-container').innerHTML = `<p style="color:red;">Error loading report data from ${JSON_PATH}: ${error.message}</p>`;
            document.getElementById('detailed-findings-container').innerHTML = "";
        });

    function getAnomalyColor(anomalyCount) {
        if (anomalyCount === 0) return '#cccccc'; // Should not happen in this map
        if (anomalyCount >= 1 && anomalyCount <= 10) {
            const scale = ['#FFFFE5', '#FFF7BC', '#FEE391', '#FEC44F', '#FE9929', '#EC7014', '#CC4C02', '#993404', '#662506', '#E31A1C'];
            return scale[anomalyCount - 1];
        }
        if (anomalyCount > 10 && anomalyCount <= 20) return '#800080'; // Purple
        if (anomalyCount > 20) return '#000000'; // Black
        return '#cccccc'; // Default
    }

    function getTrendColor(slope) {
        return slope > 0 ? '#d73027' : '#4575b4'; // Red for up, Blue for down
    }

    function updateAnomaliesMap(findings, h3Col, secondaryCol) {
        if (findings.length === 0) {
            document.getElementById('map-anomalies').innerHTML = "<p>No significant anomalies found.</p>";
            return;
        }

        const h3Summary = {};
        findings.forEach(finding => {
            const details = finding.details;
            const h3Index = details[h3Col];
            if (!h3Summary[h3Index]) {
                h3Summary[h3Index] = { anomalies: [], lat: details.lat, lon: details.lon };
            }
            h3Summary[h3Index].anomalies.push(finding);
        });

        const allLats = findings.map(f => f.details.lat);
        const allLons = findings.map(f => f.details.lon);
        if (allLats.length > 0) {
            const avgLat = allLats.reduce((a, b) => a + b, 0) / allLats.length;
            const avgLon = allLons.reduce((a, b) => a + b, 0) / allLons.length;
            mapAnomalies.setView([avgLat, avgLon], 12);
        }

        Object.keys(h3Summary).forEach(h3Index => {
            const summary = h3Summary[h3Index];
            const boundary = h3.cellToBoundary(h3Index, true);
            const leafletBoundary = boundary.map(p => [p[1], p[0]]);
            const numAnomalies = summary.anomalies.length;

            let popupHtml = `<b>Hexagon:</b> ${h3Index}<br><b>Anomalies:</b> ${numAnomalies}<hr><ul>`;
            summary.anomalies.forEach(a => popupHtml += `<li>${a.details[secondaryCol]} on ${a.week_details.week}: Count ${a.week_details.count} (p=${a.week_details.anomaly_p_value.toPrecision(2)})</li>`);
            popupHtml += "</ul>";

            const fillColor = getAnomalyColor(numAnomalies);
            L.polygon(leafletBoundary, { color: 'black', weight: 1, fillColor, fillOpacity: 0.7 })
                .addTo(mapAnomalies)
                .bindPopup(popupHtml)
                .bindTooltip(`${h3Index}: ${numAnomalies} anomaly(s)`);
        });

        const legend = L.control({position: 'bottomright'});
        legend.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'info legend');
            const grades = [
                {label: '1-3 Anomalies', color: '#FEE391'},
                {label: '4-6 Anomalies', color: '#FE9929'},
                {label: '7-10 Anomalies', color: '#CC4C02'},
                {label: '11-20 Anomalies', color: '#800080'},
                {label: '> 20 Anomalies', color: '#000000'}
            ];
            div.innerHTML += '<b>Anomaly Count</b><br>';
            grades.forEach(g => div.innerHTML += `<i style="background:${g.color}"></i> ${g.label}<br>`);
            return div;
        };
        legend.addTo(mapAnomalies);
    }

    function updateTrendsMap(findings, h3Col, secondaryCol) {
        if (findings.length === 0) {
            document.getElementById('map-trends').innerHTML = "<p>No significant trends found.</p>";
            return;
        }

        const h3Summary = {};
        findings.forEach(finding => {
            const details = finding.details;
            const h3Index = details[h3Col];
            if (!h3Summary[h3Index]) {
                h3Summary[h3Index] = { trends: [], lat: details.lat, lon: details.lon, total_slope: 0 };
            }
            h3Summary[h3Index].trends.push(finding);
            h3Summary[h3Index].total_slope += finding.trend_details.slope;
        });

        const allLats = findings.map(f => f.details.lat);
        const allLons = findings.map(f => f.details.lon);
        if (allLats.length > 0) {
            const avgLat = allLats.reduce((a, b) => a + b, 0) / allLats.length;
            const avgLon = allLons.reduce((a, b) => a + b, 0) / allLons.length;
            mapTrends.setView([avgLat, avgLon], 12);
        }

        Object.keys(h3Summary).forEach(h3Index => {
            const summary = h3Summary[h3Index];
            const boundary = h3.cellToBoundary(h3Index, true);
            const leafletBoundary = boundary.map(p => [p[1], p[0]]);
            const numTrends = summary.trends.length;

            let popupHtml = `<b>Hexagon:</b> ${h3Index}<br><b>Trends:</b> ${numTrends}<hr><ul>`;
            summary.trends.forEach(t => {
                const trend = t.trend_details;
                const slopeText = trend.slope ? `Slope: ${trend.slope.toFixed(2)}, ` : '';
                popupHtml += `<li><strong>${t.details.secondary_group}</strong> (${t.period.replace('_', ' ')}): ${trend.description} (${slopeText}p=${trend.p_value.toPrecision(2)})</li>`;
            });
            popupHtml += "</ul>";

            const avgSlope = summary.total_slope / numTrends;
            const fillColor = getTrendColor(avgSlope);
            L.polygon(leafletBoundary, { color: 'black', weight: 1, fillColor, fillOpacity: 0.7 })
                .addTo(mapTrends)
                .bindPopup(popupHtml)
                .bindTooltip(`${h3Index}: ${numTrends} trend(s)`);
        });

        const legend = L.control({position: 'bottomright'});
        legend.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'info legend');
            div.innerHTML += '<b>Trend Direction</b><br>';
            div.innerHTML += '<i style="background:#d73027"></i> Upward Trend<br>';
            div.innerHTML += '<i style="background:#4575b4"></i> Downward Trend<br>';
            return div;
        };
        legend.addTo(mapTrends);
    }

    function populateSummaryTable(findings, h3Col, secondaryCol) {
        findings.sort((a, b) => {
            const pValA = a.type === 'Trend' ? a.trend_details.p_value : a.week_details.anomaly_p_value;
            const pValB = b.type === 'Trend' ? b.trend_details.p_value : b.week_details.anomaly_p_value;
            return a.details[h3Col].localeCompare(b.details[h3Col]) || pValA - pValB;
        });

        let tableHtml = `<table><thead><tr><th>H3 Cell</th><th>${secondaryCol || 'Secondary Group'}</th><th>Finding Type</th><th>Date/Period</th><th>Details</th><th>P-Value</th><th>Z-Score / Slope</th></tr></thead><tbody>`;
        findings.forEach(finding => {
            const details = finding.details;
            tableHtml += `<tr><td><a href='#${details[h3Col]}'>${details[h3Col]}</a></td><td>${details.secondary_group}</td>`;
            if (finding.type === 'Trend') {
                const trend = finding.trend_details;
                tableHtml += `<td>Trend</td><td>${finding.period.replace('_', ' ')}</td><td>${trend.description}</td><td>${trend.p_value.toPrecision(4)}</td><td>${trend.slope.toFixed(2)}</td>`;
            } else {
                const week = finding.week_details;
                tableHtml += `<td>Anomaly</td><td>${week.week}</td><td>Count: ${week.count} (vs avg ${details.historical_weekly_avg.toFixed(2)})</td><td>${week.anomaly_p_value.toPrecision(4)}</td><td>${week.z_score.toFixed(2)}</td>`;
            }
            tableHtml += "</tr>";
        });
        tableHtml += '</tbody></table>';
        document.getElementById('summary-table-container').innerHTML = tableHtml;
    }

    function sanitizeForFilename(name) {
        // A simple version of the Python sanitization. 
        // Removes characters that are problematic in URLs/filenames.
        return name.replace(/[\\/*?:"<>|]/g, "");
    }

    function populateDetailedFindings(findings, cityWideResults, h3Col, secondaryCol) {
        const findingsByH3 = {};
        findings.forEach(f => {
            const h3Index = f.details[h3Col];
            if (!findingsByH3[h3Index]) findingsByH3[h3Index] = [];
            findingsByH3[h3Index].push(f);
        });

        const cityWideMap = {};
        cityWideResults.forEach(item => cityWideMap[item.secondary_group] = item);

        let detailedHtml = '';
        Object.keys(findingsByH3).sort().forEach(h3Index => {
            detailedHtml += `<div class="finding-group" id="${h3Index}"><h4>Hexagon: ${h3Index}</h4>`;
            
            // Group findings by secondary column to show one plot per group
            const findingsBySecGroup = {};
            findingsByH3[h3Index].forEach(f => {
                const secGroup = f.details.secondary_group;
                if (!findingsBySecGroup[secGroup]) findingsBySecGroup[secGroup] = [];
                findingsBySecGroup[secGroup].push(f);
            });

            Object.keys(findingsBySecGroup).forEach(secGroup => {
                detailedHtml += `<div class="finding-card"><h5>Findings for '${secGroup}'</h5>`;
                
                // Add all finding details (trends, anomalies)
                detailedHtml += '<ul>';
                findingsBySecGroup[secGroup].forEach(finding => {
                    if (finding.type === 'Trend') {
                        const trend = finding.trend_details;
                        detailedHtml += `<li><strong>Trend (${finding.period.replace('_', ' ')})</strong>: ${trend.description} (Slope: ${trend.slope.toFixed(2)}, p-value: ${trend.p_value.toPrecision(4)})</li>`;
                    } else {
                        const week = finding.week_details;
                        detailedHtml += `<li><strong>Anomaly on ${week.week}</strong>: Count ${week.count} (vs avg ${finding.details.historical_weekly_avg.toFixed(2)}), Z-Score: ${week.z_score.toFixed(2)}, p-value: ${week.anomaly_p_value.toPrecision(4)})</li>`;
                    }
                });
                detailedHtml += '</ul>';

                // Add the plot for this H3/secondary group combination
                const sanitizedSecGroup = sanitizeForFilename(String(secGroup));
                const plotFilename = `plot_${h3Index}_${sanitizedSecGroup}.png`;
                const plotUrl = `/api/v1/jobs/${jobId}/results/${plotFilename}`;
                detailedHtml += `<img src="${plotUrl}" alt="Time series plot for ${secGroup} in ${h3Index}" style="width:100%; max-width:600px;" onerror="this.style.display='none'"/>`;

                detailedHtml += '</div>'; // Close finding-card
            });

            detailedHtml += '</div>'; // Close finding-group
        });
        document.getElementById('detailed-findings-container').innerHTML = detailedHtml;
    }

    function generateMethodology(secondary_col, h3_res, p_anomaly, p_trend, weeks_trend, weeks_anomaly) {
        const max_weeks = Math.max(...weeks_trend, weeks_anomaly);
        return `
            <h2>1. Methodology</h2>
            <p>The analytical approach comprises several sequential steps: spatial aggregation, data preparation, model selection, and independent significance testing.</p>
            <h3>1.1. Spatial Aggregation and Data Preparation</h3>
            <p>Raw incident data points were assigned to a hexagonal H3 cell based on their latitude and longitude coordinates, using H3 resolution <code>${h3_res}</code>. The data was then further partitioned into subgroups based on unique combinations of the H3 cell and the <code>${secondary_col}</code> field. For each subgroup, a time series was constructed by resampling the data into weekly incident counts. A minimum of ${max_weeks + 4} weeks of data was required for a subgroup to be included in the analysis.</p>
            <h3>1.2. Probabilistic Model Selection and Anomaly/Trend Detection</h3>
            <p>The methodology for model selection (Poisson vs. Negative Binomial) is based on the historical data preceding the analysis window. Anomaly detection (p-value and z-score) is performed on the most recent <strong>${weeks_anomaly}</strong> weeks, while trend detection (linear regression) is performed over several recent time windows: <strong>${weeks_trend.join(', ')}</strong> weeks. Please refer to the standard univariate analysis report for detailed descriptions of the statistical models.</p>
            <h3>1.3. Significance Testing and Noise Reduction</h3>
            <p>Each time series is treated as an independent hypothesis test. A conventional significance level (alpha) of <strong>${p_anomaly}</strong> for anomalies and <strong>${p_trend}</strong> for trends is used. A finding is reported as statistically significant if its p-value is less than the respective threshold. To reduce noise, anomalies are only reported for low-frequency series if the observed count is greater than 1.</p>
        `;
    }

    function generateAppendix() {
        return `
            <hr><h2>Appendix: Definition of Terms</h2>
            <ul>
                <li><strong>H3</strong>: A geospatial indexing system that partitions the world into hexagonal cells. It allows for efficient spatial analysis at various resolutions.</li>
                <li><strong>Leaflet.js</strong>: An open-source JavaScript library for mobile-friendly interactive maps.</li>
                <li><strong>Poisson Distribution</strong>: A discrete probability distribution for the counts of events that occur randomly in a given interval of time or space.</li>
                <li><strong>Negative Binomial Distribution</strong>: A generalization of the Poisson distribution that allows for overdispersion, where the variance is greater than the mean.</li>
                <li><strong>P-value</strong>: The probability of obtaining test results at least as extreme as the results actually observed, under the assumption that the null hypothesis is correct.</li>
                <li><strong>Z-score</strong>: A measure of how many standard deviations an observation or data point is from the mean of a distribution. It provides a standardized measure of an anomaly's magnitude.</li>
            </ul>
        `;
    }
});
</script>
</body>
</html>
